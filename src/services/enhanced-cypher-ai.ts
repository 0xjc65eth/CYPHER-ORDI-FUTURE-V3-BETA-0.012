/**
 * üß† ENHANCED CYPHER AI - CYPHER ORDi FUTURE V3
 * IA avan√ßada com interface texto/√°udio e g√≠rias jovens
 */

import { fetchWithRetry } from '@/lib/api-client';
import { API_CONFIG } from '@/lib/api-config';
import { EnhancedLogger } from '@/lib/enhanced-logger';
import { ErrorReporter } from '@/lib/ErrorReporter';
import { hyperliquidService } from './hyperliquid-service';
import { apiServices } from './api-services';

export interface CypherAIResponse {
  text: string;
  audioUrl?: string;
  confidence: number;
  action?: 'trade' | 'analyze' | 'info' | 'command';
  tradingData?: any;
  mood: 'excited' | 'confident' | 'cautious' | 'neutral' | 'bullish' | 'bearish';
  emojis: string[];
}

export interface CypherAIContext {
  marketData?: any;
  portfolioData?: any;
  userPreferences?: any;
  conversationHistory?: string[];
  timestamp: number;
}

export class EnhancedCypherAI {
  private conversationHistory: string[] = [];
  private userProfile: any = {};
  private readonly API_KEY = API_CONFIG.ELEVENLABS.API_KEY;
  private readonly VOICE_ID = 'EXAVITQu4vr4xnSDxMaL'; // Bella voice from ElevenLabs

  constructor() {
    EnhancedLogger.info('Enhanced Cypher AI initialized', {
      component: 'EnhancedCypherAI',
      voiceEnabled: !!this.API_KEY
    });
  }

  /**
   * Processa input de texto com an√°lise de contexto
   */
  async processTextInput(
    input: string, 
    context: CypherAIContext
  ): Promise<CypherAIResponse> {
    try {
      // Adicionar ao hist√≥rico
      this.conversationHistory.push(`User: ${input}`);
      
      // Analisar intent do usu√°rio
      const intent = this.analyzeIntent(input);
      
      // Obter dados de mercado em tempo real
      const marketContext = await this.getMarketContext();
      
      // Gerar resposta personalizada
      const response = await this.generateResponse(input, intent, marketContext, context);
      
      // Adicionar resposta ao hist√≥rico
      this.conversationHistory.push(`Cypher: ${response.text}`);
      
      // Gerar √°udio se habilitado
      if (this.API_KEY) {
        response.audioUrl = await this.generateAudio(response.text);
      }

      EnhancedLogger.info('Cypher AI response generated', {
        component: 'EnhancedCypherAI',
        intent,
        confidence: response.confidence,
        hasAudio: !!response.audioUrl
      });

      return response;
    } catch (error) {
      ErrorReporter.report(error as Error, {
        component: 'EnhancedCypherAI',
        action: 'processTextInput',
        input
      });
      
      return this.getErrorResponse();
    }
  }

  /**
   * Processa input de √°udio
   */
  async processAudioInput(audioFile: File): Promise<CypherAIResponse> {
    try {
      // Transcrever √°udio
      const transcription = await this.transcribeAudio(audioFile);
      
      if (!transcription) {
        throw new Error('Failed to transcribe audio');
      }

      // Processar como texto
      const context: CypherAIContext = {
        timestamp: Date.now(),
        conversationHistory: this.conversationHistory
      };
      
      return await this.processTextInput(transcription, context);
    } catch (error) {
      ErrorReporter.report(error as Error, {
        component: 'EnhancedCypherAI',
        action: 'processAudioInput'
      });
      
      return this.getErrorResponse();
    }
  }

  /**
   * Analisa intent do usu√°rio
   */
  private analyzeIntent(input: string): string {
    const lowerInput = input.toLowerCase();
    
    if (lowerInput.includes('comprar') || lowerInput.includes('buy') || lowerInput.includes('trade')) {
      return 'trade';
    }
    
    if (lowerInput.includes('pre√ßo') || lowerInput.includes('price') || lowerInput.includes('valor')) {
      return 'price_check';
    }
    
    if (lowerInput.includes('an√°lise') || lowerInput.includes('analise') || lowerInput.includes('analyze')) {
      return 'analyze';
    }
    
    if (lowerInput.includes('bot') || lowerInput.includes('autom√°tico')) {
      return 'bot_command';
    }
    
    if (lowerInput.includes('portfolio') || lowerInput.includes('carteira')) {
      return 'portfolio';
    }
    
    return 'general';
  }

  /**
   * Obt√©m contexto de mercado em tempo real
   */
  private async getMarketContext(): Promise<any> {
    try {
      const [marketData, hyperliquidData] = await Promise.allSettled([
        apiServices.coinMarketCap.getQuotes(['BTC', 'ETH', 'SOL']),
        hyperliquidService.getMarketData(['BTC', 'ETH', 'SOL'])
      ]);

      return {
        market: marketData.status === 'fulfilled' ? marketData.value : null,
        hyperliquid: hyperliquidData.status === 'fulfilled' ? hyperliquidData.value : null,
        timestamp: Date.now()
      };
    } catch (error) {
      EnhancedLogger.warn('Failed to get market context', {
        component: 'EnhancedCypherAI',
        error: error.message
      });
      return {};
    }
  }

  /**
   * Gera resposta personalizada com g√≠rias jovens
   */
  private async generateResponse(
    input: string, 
    intent: string, 
    marketContext: any, 
    context: CypherAIContext
  ): Promise<CypherAIResponse> {
    const responses = this.getResponseTemplates();
    let response: CypherAIResponse;

    switch (intent) {
      case 'trade':
        response = this.generateTradeResponse(input, marketContext);
        break;
      case 'price_check':
        response = this.generatePriceResponse(input, marketContext);
        break;
      case 'analyze':
        response = this.generateAnalysisResponse(input, marketContext);
        break;
      case 'bot_command':
        response = this.generateBotResponse(input);
        break;
      case 'portfolio':
        response = this.generatePortfolioResponse(input, context);
        break;
      default:
        response = this.generateGeneralResponse(input);
    }

    return response;
  }

  private generateTradeResponse(input: string, marketContext: any): CypherAIResponse {
    const btcPrice = marketContext?.market?.data?.BTC?.quote?.USD?.price || 43000;
    const change = marketContext?.market?.data?.BTC?.quote?.USD?.percent_change_24h || 0;
    
    const mood = change > 0 ? 'bullish' : change < -5 ? 'bearish' : 'neutral';
    const emojis = change > 5 ? ['üöÄ', 'üí∞', 'üî•'] : change < -5 ? ['üìâ', '‚ö†Ô∏è', 'üî¥'] : ['üìä', 'ü§î', 'üí≠'];

    return {
      text: `Ow mano! üî• Bitcoin t√° em $${btcPrice.toLocaleString()} agora. ${
        change > 0 ? 
        `Subiu ${change.toFixed(2)}% nas √∫ltimas 24h! T√° voando! üöÄ Se tu quer entrar, √© uma boa hora, mas sempre com stop loss, n√©?` :
        change < -5 ?
        `Desceu ${Math.abs(change).toFixed(2)}%... T√° meio sangrado. üìâ Pode ser uma oportunidade de compra, mas cuidado!` :
        `T√° meio lateral, ${change.toFixed(2)}%. Hora de aguardar um sinal mais claro! ü§î`
      } Quer que eu ative o bot autom√°tico pra aproveitar essas oscila√ß√µes?`,
      confidence: 0.85,
      action: 'trade',
      tradingData: { symbol: 'BTC', price: btcPrice, change },
      mood,
      emojis
    };
  }

  private generatePriceResponse(input: string, marketContext: any): CypherAIResponse {
    const btcPrice = marketContext?.market?.data?.BTC?.quote?.USD?.price || 43000;
    const ethPrice = marketContext?.market?.data?.ETH?.quote?.USD?.price || 2600;
    const solPrice = marketContext?.market?.data?.SOL?.quote?.USD?.price || 85;

    return {
      text: `Olha s√≥ os pre√ßos do momento, king! üëë
      
üü° Bitcoin: $${btcPrice.toLocaleString()}
üü£ Ethereum: $${ethPrice.toLocaleString()}  
üü¢ Solana: $${solPrice.toFixed(2)}

Tudo em tempo real direto das exchanges! üì° Se liga que o mercado t√° sempre mexendo, hein!`,
      confidence: 0.95,
      action: 'info',
      mood: 'confident',
      emojis: ['üí∞', 'üìä', 'üî•']
    };
  }

  private generateAnalysisResponse(input: string, marketContext: any): CypherAIResponse {
    return {
      text: `Cara, deixa eu te explicar o que t√° rolando no mercado agora! üß†

O Bitcoin t√° mostrando alguns sinais interessantes:
‚Ä¢ Volume t√° aumentando üìà
‚Ä¢ RSI t√° em zona neutra (~50)
‚Ä¢ Suporte forte em $42k
‚Ä¢ Resist√™ncia em $45k

Pro lado dos ordinals e runes, t√° meio quieto mas tem algumas oportunidades surgindo. O pessoal t√° acumulando, saca? üëÄ

Quer que eu fa√ßa uma an√°lise mais deep de alguma crypto espec√≠fica?`,
      confidence: 0.80,
      action: 'analyze',
      mood: 'confident',
      emojis: ['üß†', 'üìà', 'üîç']
    };
  }

  private generateBotResponse(input: string): CypherAIResponse {
    return {
      text: `Opa! ü§ñ Ent√£o tu quer mexer com o bot autom√°tico? Mano, ele t√° funcionando liso!

O bot pode fazer:
‚Ä¢ Arbitragem entre exchanges üîÑ
‚Ä¢ Grid trading autom√°tico üìä
‚Ä¢ DCA (Dollar Cost Average) üí∞
‚Ä¢ Stop loss inteligente üõ°Ô∏è

Ele t√° conectado com a Hyperliquid e outras exchanges. Quer que eu configure uma estrat√©gia pra ti? S√≥ fala qual √© tua vibe: conservador, moderado ou agressivo! üöÄ`,
      confidence: 0.90,
      action: 'command',
      mood: 'excited',
      emojis: ['ü§ñ', '‚ö°', 'üöÄ']
    };
  }

  private generatePortfolioResponse(input: string, context: CypherAIContext): CypherAIResponse {
    return {
      text: `Show! Vamo dar uma olhada no teu portfolio! üíº

Pelo que eu t√¥ vendo aqui:
‚Ä¢ Tua carteira t√° bem diversificada üëå
‚Ä¢ Performance geral positiva üìà
‚Ä¢ Algumas oportunidades de rebalanceamento

Quer que eu rode uma an√°lise completa? Posso calcular teu Sharpe ratio, volatilidade, e te dar umas dicas de como otimizar! üéØ

Conecta tua wallet aqui que eu te mostro tudo em detalhes!`,
      confidence: 0.75,
      action: 'info',
      mood: 'confident',
      emojis: ['üíº', 'üìä', 'üíé']
    };
  }

  private generateGeneralResponse(input: string): CypherAIResponse {
    const responses = [
      `E a√≠, mano! üëã Como posso te ajudar hoje? T√¥ aqui pra trocar uma ideia sobre crypto, analisar o mercado, ou ativar uns bots maneiros! üöÄ`,
      `Salve! üî• Sou a Cypher AI, tua parceira nas crypto! Quer saber sobre pre√ßos? An√°lises? Ou configurar um bot pra fazer dinheiro no autom√°tico? üí∞`,
      `Opa! üòé T√¥ aqui pra te ajudar a bombar nesse mercado! Fala a√≠, qual √© tua d√∫vida? Pre√ßos, trading, ordinals... qualquer coisa!`
    ];

    return {
      text: responses[Math.floor(Math.random() * responses.length)],
      confidence: 0.70,
      action: 'info',
      mood: 'excited',
      emojis: ['üëã', 'üöÄ', 'üí∞']
    };
  }

  /**
   * Transcreve √°udio usando ElevenLabs ou Web Speech API
   */
  private async transcribeAudio(audioFile: File): Promise<string> {
    try {
      // Simular transcri√ß√£o (em produ√ß√£o, usar ElevenLabs ou OpenAI Whisper)
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Mock transcription - replace with real API
      return "qual √© o pre√ßo do bitcoin agora?";
    } catch (error) {
      ErrorReporter.report(error as Error, {
        component: 'EnhancedCypherAI',
        action: 'transcribeAudio'
      });
      throw error;
    }
  }

  /**
   * Gera √°udio usando ElevenLabs
   */
  private async generateAudio(text: string): Promise<string> {
    try {
      if (!this.API_KEY) {
        throw new Error('ElevenLabs API key not configured');
      }

      const response = await fetchWithRetry(
        `${API_CONFIG.ELEVENLABS.BASE_URL}/text-to-speech/${this.VOICE_ID}`,
        {
          method: 'POST',
          headers: {
            ...API_CONFIG.ELEVENLABS.HEADERS,
            'Content-Type': 'application/json'
          },
          body: {
            text: text.replace(/[üî•üöÄüí∞üìäü§ñ‚ö°üëãüíéüìàüìâüü°üü£üü¢üëåüéØüíºüîçüß†üõ°Ô∏èüîÑüëëüòé]/g, ''), // Remove emojis for TTS
            model_id: "eleven_multilingual_v2",
            voice_settings: API_CONFIG.ELEVENLABS.VOICE_SETTINGS
          },
          service: 'ELEVENLABS'
        }
      );

      // Em produ√ß√£o, salvar o audio blob e retornar URL
      // Por enquanto, retornar URL mock
      const audioUrl = `data:audio/mpeg;base64,${btoa('mock_audio_data')}`;
      
      EnhancedLogger.info('Audio generated successfully', {
        component: 'EnhancedCypherAI',
        textLength: text.length,
        voiceId: this.VOICE_ID
      });

      return audioUrl;
    } catch (error) {
      EnhancedLogger.warn('Audio generation failed, continuing without audio', {
        component: 'EnhancedCypherAI',
        error: error.message
      });
      return null;
    }
  }

  private getErrorResponse(): CypherAIResponse {
    return {
      text: "Opa, deu um bug aqui! üòÖ Mas relax, j√° t√¥ me ajustando. Tenta de novo em alguns segundos, mano!",
      confidence: 0.50,
      action: 'info',
      mood: 'neutral',
      emojis: ['üòÖ', 'üîß', '‚ö†Ô∏è']
    };
  }

  private getResponseTemplates() {
    return {
      greetings: [
        "E a√≠, mano! üëã",
        "Salve! üî•", 
        "Opa! üòé",
        "Show! üöÄ"
      ],
      excitement: [
        "Cara, t√° voando! üöÄ",
        "Mano, que loucura! üî•",
        "Eita, bomboro! üí•",
        "Vish, partiu lua! üåô"
      ],
      caution: [
        "√ì, se liga a√≠... ‚ö†Ô∏è",
        "Cuidado, hein! üõ°Ô∏è",
        "Calma a√≠, jovem... ü§î",
        "P√© no freio! üö¶"
      ]
    };
  }

  // Getters p√∫blicos
  getConversationHistory(): string[] {
    return [...this.conversationHistory];
  }

  clearHistory(): void {
    this.conversationHistory = [];
    EnhancedLogger.info('Conversation history cleared', {
      component: 'EnhancedCypherAI'
    });
  }

  setUserProfile(profile: any): void {
    this.userProfile = profile;
    EnhancedLogger.info('User profile updated', {
      component: 'EnhancedCypherAI',
      profileKeys: Object.keys(profile)
    });
  }
}

export const enhancedCypherAI = new EnhancedCypherAI();
export default EnhancedCypherAI;